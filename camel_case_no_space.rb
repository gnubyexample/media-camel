#!/usr/bin/ruby1.8 -W1 
###
#    This file is part of media-camel
#
#    media-camel is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    media-camel is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with media-camel.  If not, see <http://www.gnu.org/licenses/>.
#
#    (c) 2011,2007 Gary Wright
#    http://wrightsolutions.co.uk/contact
#    http://identi.ca/gnubyexample
###
# Expects a list of files as input on stdin (perhaps generated by the find shell command) 
# V2.0 20110514GW name now camel_case_no_space 
# V1.9 20070829GW ruby 19 compatibality plus some minor case handling adjustments.
# V1.8 20070815GW & becomes And
# V1.7 20070725GW Comma no thanks
# V1.6 20070725GW op. handling for the classical listener
# V1.6 20070713GW Removal of dot between track number and trackname
# V1.5 20070713GW Added method delim_based_on_after
# V1.4 20070713GW Added replacement of left parenthesis with underscore
# V1.3 20070713GW Added mode of max to strip out less savoury characters
# V1.2 20070713GW When mv would result in same source and dest, preceed mv with a commenting # symbol
# V1.1 20070713GW Chomptastic and default $cmdbin so can be invoked with no arguments.
# V1.0 20070712GW 

if __FILE__ == $0
#exit 2 unless ARGV.length > 0   # exit 2 LSB wrong/invalid
#if ARGV.length > 0   # exit 2 LSB wrong/invalid
	$cmdbin = (ARGV.length > 0) ? ARGV[0] : 'mv'	# mv md5sum
	$mode = (ARGV.length > 1) ? ARGV[1] : 'std'	# min std max
#end
print("#{$0} Invoked with arguments #{$cmdbin} #{$mode}.\n") if $DEBUG

def this_method();return (caller[0]=~/`([^']*)'/)?$1:'unknown';end

def ccase(word)
	#return word if word.length == 0
	#word.sub(". ",".") if word =~ /\A\d+\./
	return word if word.length < 2 			# If a single letter word then leave case as it is
	print('###Method:',this_method(),' beggining processing with of length ',word.length,' being ',word,"\n") if $DEBUG
	#wordtr = word.tr!('^a-zA-Z0-9.','')		# word <=> wordtr > 0 would mean that some characters removed
	if word =~ /[^a-zA-Z0-9.]/			# . rather than \. is fine here
		beforematch = $`; matching = $&; aftermatch = $'
		#Next we will seek for any digit match
		beforematch = '' if beforematch.nil?
		#wordnew += (beforematch =~ /^\d/) ? beforematch : beforematch.capitalize unless beforematch.nil?
		#wordnew = (beforematch =~ /^\d/) ? beforematch : ccase(beforematch) unless beforematch.nil?
		wordnew = (beforematch =~ /^\d/) ? beforematch : ccase(beforematch)
		###print("ccase about to enter case matching with beforematch of ",beforematch,"\n") if $DEBUG
		print('#ccase of word:',word,' about to enter case matching with matching of ',matching,"\n") if $DEBUG
		#print("ccase about to enter case matching with aftermatch of ",aftermatch,"\n") if $DEBUG
		case matching
			#when '_' then wordnew += matching unless $mode == 'max' && aftermatch =~ /^[^Feat]/i
			when '_' 
				if $mode == 'max'
					if beforematch =~ /\A\d+\Z/ && aftermatch =~ /\A\d+\Z/	# digits either side
						wordnew += 'p'						# Classical part delimiter will be p
					elsif beforematch =~ /p\d+\Z/
						wordnew += matching
					else	
						#Likely to want to strip the character but inspect value of after before committing
						#wordnew += delim_based_on_after(matching,aftermatch,'feat',false)
						wordnew +=
							delim_based_on_after(matching,aftermatch,Array['bonus','feat','hidden','remix','op.'],false)
					end
				else
					wordnew += matching
				end
			when "'" then 
			#when '(' : wordnew += ($mode == 'min') ? matching : '_' 
			when '(','[' 
				###print("ccase dealing with opening paranthesis\n") if $DEBUG
				aftermatch = ccase(aftermatch)		# Nested call as we now guess to expect closing paranthesis 
				if ($mode == 'min') then wordnew += matching
				else
					wordnew += '_' unless beforematch == '_'	# Avoid repeating _
				end
			#when ')' then wordnew += ($mode == 'min') ? matching : '' 
			when ')',']' 
				###print("ccase dealing with closing paranthesis\n") if $DEBUG
				if ($mode == 'min') then wordnew += matching
				else
					wordnew += '_' unless aftermatch.nil? || aftermatch =~ /^\./
				end
			when "," then 									# comma no thanks
			when "&" then wordnew += 'And'							# & becomes And
			else
				print('###Method:',this_method(),"The matching value of:",matching," was dealt with by else selector.") if $DEBUG
				wordnew += matching
		end
		#wordnew += matching unless $mode == 'max' && matching == '_'
		#wordnew += (aftermatch =~ /^\d/) ? aftermatch : aftermatch.capitalize unless aftermatch.nil?
		#print("dot squish testing based on aftermatch of:",aftermatch,"\n") if $DEBUG
		if aftermatch =~ /bonus\./i or aftermatch =~ /feat\./i or
			aftermatch =~ /hidden\./i or aftermatch =~ /remix\./ or aftermatch =~/op\./
				print("dot squish will now be done based on aftermatch of:",aftermatch,"\n") if $DEBUG
				aftermatch.sub!(".","")
		end
		wordnew += (aftermatch =~ /^\d/ || matching == "'") ? aftermatch.delete(%q(')) : ccase(aftermatch) unless aftermatch.nil? 
	else 
		print("ccase alphanumericish workings using word of:",word,"\n") if $DEBUG
		#print("dot squish testing based on word of:",word,"\n") if $DEBUG
		if word =~ /bonus\./i or word =~ /feat\./i or
			word =~ /hidden\./i or word =~ /remix\./i or word =~/op\./i
				#word = delim_based_on_after('_',word,Array['bonus','feat','hidden','remix','op.'],false) + word# before dot squish
				print("dot squish will now be done based on word of:",word,"\n") if $DEBUG
				word.sub!(".","")
		end
		#word = (word =~ /\A\d+\./) if word.count(".") == 1 && word =~ /\A\d+\./ # wrong place to check for dot between track num and name
		wordnew = (word.nil? or word.length < 2) ? word : word.capitalize 	# If a single letter word then leave case as it is
		#wordnew += ccase(word)
	end
	#wordnew = word.capitalize				# Camel case
	return word if wordnew.count('A-Z') < word.count('A-Z')	
	return wordnew
end

def delim_based_on_after(delim,after,starts_with_to_retain_delim,case_sensitive_flag)
	if starts_with_to_retain_delim.class.to_s != 'Array'
		print('###Method:',this_method(),' entered using after of ',after,"END\n") if $DEBUG
		#print('###Method:',this_method(),' entered using starts_with_to_retain_delim of type ',
		#	starts_with_to_retain_delim.class,"\n") if $DEBUG
	end
	return '' if after.length < 1
	return delim if delim != ' ' && delim.length == 1 && delim[0] == after[0] # non space character repeated replaced by single occurence
	delimnew = ''
	#if Object.kind_of?(starts_with_to_retain_delim) == 'Array'	# kind_of? for objects whereas variables should use .class
	if starts_with_to_retain_delim.class.to_s == 'Array'
		print(starts_with_to_retain_delim.class," based processing begins...\n") if $DEBUG
		starts_with_to_retain_delim.each { |starts_with|
			delimret = delim_based_on_after(delim,after,starts_with,case_sensitive_flag)
			return delim if delimret == delim	# Shortcut based on a relevant decision already has been made
		}
		return delimnew
	else
		#print("Non-array based processing begins...\n") if $DEBUG
		#print(starts_with_to_retain_delim.class,"\n") if $DEBUG
	end
	###print("After test will be performed on ",after,".\n") if $DEBUG
	#print("After test 0 results in ",after =~ /op\./i,".\n") if $DEBUG
	###print("After test 1sensitive results in position ",after.index(starts_with_to_retain_delim),".\n") if $DEBUG
	print("After test 2insensitive results in postition ",after.downcase.index(starts_with_to_retain_delim.downcase),".\n") if $DEBUG
	return delim if starts_with_to_retain_delim.nil? || starts_with_to_retain_delim.length < 1
	case case_sensitive_flag 
		when true then delimnew = delim if after.index(starts_with_to_retain_delim) == 0
		when false then delimnew = delim if after.downcase.index(starts_with_to_retain_delim.downcase) == 0
		else
	end
	return delimnew
end

def lineoutn(fline,oline)
	case $cmdbin
		#when 'mv' then print('mv "',fline.chomp,'" ',oline,";\n") unless fline.chomp == oline
		when 'mv'
			cmdbinout = (fline.chomp == oline) ? "#" + $cmdbin + ' ' : $cmdbin + ' '
			#print(cmdbinout,'"',fline.chomp,'" ',oline,";\n") 
			#print(cmdbinout,'"',fline.chomp.dump,'" ',oline,";\n") 
			#print(cmdbinout,fline.chomp.dump,' ',oline,";\n") 
			#iline = fline.chomp.unpack('M*')
			#print(cmdbinout,iline,' ',oline,";\n") 
			#iline = fline.chomp.gsub("'",%{\'} + %q('))	# 39 is code for ' and %{} means string literal
			#print(cmdbinout,iline,' ',oline,";\n") 
			print(cmdbinout,'"',fline.chomp,'" ',oline,";\n") 
		when /^md5/ then print('md5sum ',fline.chomp,' > ',fline.chomp,".md5.a2k;\n")
	end
	#oline = $linewordcount
end

while fline = $stdin.gets
	#print("Processing an input line...\n") if $DEBUG
	#fline.sub("./","") if fline =~ /\A\.\//
	if fline =~ /\A\.\//
		#output from printf "%f\n" is best but lets fix the input for the inexperienced user of find command
		fline.sub!("./","")
	end
	$linewordcount = 1
	$oline = ''
	#Next split on whitespace
	fline.split(/\s/).each() {
		|wtoken|
		if !wtoken.nil?
			if wtoken =~ /\A\d+\./
				#print("dot space replaced with dot in word:",wtoken,"\n") if $DEBUG
				($mode == 'max') ? wtoken.gsub!(". ",".") : wtoken.sub!(". ",".")
			end
			#if wtoken =~ /\W/
			#if wtoken =~ /-/
			if wtoken =~ /-|_/
				#wtoken = $&
				#wtoken = [$1,$&,$2].join
				#$oline += $2.capitalize
				#$oline += $`
				beforematch = $`; matching = $&; aftermatch = $'
				###print("fline.split about to enter case matching with beforematch of ",beforematch,"\n") if $DEBUG
				print('fline.split of wtoken:',wtoken,' about to enter case matching with matching of ',matching,"\n") if $DEBUG
				#print("fline.split about to enter case matching with aftermatch of ",aftermatch,"\n") if $DEBUG
				#Next we will seek for any digit match
				#$oline += (beforematch =~ /^\d/) ? beforematch : beforematch.capitalize unless beforematch.nil?
				$oline += (beforematch =~ /^\d/) ? beforematch : ccase(beforematch) unless beforematch.nil?
				if $mode == 'max' && ['-','_'].include?(matching)
					if beforematch =~ /\A\d+\Z/ && aftermatch =~ /\A\d+\Z/	# digits either side
						$oline += 'p'						# Classical part delimiter will be p
					elsif beforematch =~ /p\d+\Z/
						$oline += matching
					else	
						#Likely to want to strip the character but inspect value of after before committing
						#$oline += delim_based_on_after(matching,aftermatch,'feat',false)
						$oline +=
							delim_based_on_after(matching,aftermatch,Array['bonus','feat','hidden','remix','op.'],false)
					end
				else
				end
				#$oline += (aftermatch =~ /^\d/) ? aftermatch : aftermatch.capitalize unless aftermatch.nil?
				$oline += (aftermatch =~ /^\d/) ? aftermatch : ccase(aftermatch) unless aftermatch.nil?
			#elsif wtoken =~ /\&/							# elsif rather than elseif please
			elsif wtoken.count('&') > 0
				print('###Method:',this_method(),' And then there were none processing has aftermatch of ',
					aftermatch,"END\n") if $DEBUG
				beforematch = $`; matching = $&; aftermatch = $'
				$oline += (beforematch =~ /^\d/) ? beforematch : ccase(beforematch) unless beforematch.nil?
				$oline += 'And'
				$oline += (aftermatch =~ /^\d/) ? aftermatch : ccase(aftermatch) unless aftermatch.nil?
			else 
				print('###Method:',this_method(),' if all else fails processing of wtoken ',wtoken,' has aftermatch of ',
					aftermatch,"END\n") if $DEBUG
				if $oline == '' && wtoken =~ /\A\d+\./
					print("track number followed by dot detected for word:",wtoken,"\n") if $DEBUG
					wtoken.sub!(".","")
				end
				#$oline += wtoken.capitalize
				$oline += ccase(wtoken)
			end
		end
		#$oline += wtoken.capitalize unless wtoken.nil?
		#$oline += wtoken
	}
	lineoutn(fline,$oline)
end
#print Time.now.strftime("%Y%m%dT%H%M") + '#-^- process' if $DEBUG
exit 0
end
__END__
__END__
#ls *.ogg | ruby camel_case_no_space.rb 'mv' 'max'
#find . -type f -name '*.ogg' | ruby camel_case_no_space.rb 'mv' 'max'
